;Credits to Blumlaut for his help with [SCRIPTABLE_DISPLAY]

[ADJUSTABLE_WING_0]
NAME = Wing_2  			; name of wing root node to rotate
WING = 2          		; index of section in aero.ini
ANGLE_BASE = -3.6  		; base offset for angle
ANGLE_MULT = 0.86  		; angle multiplier
DEBUG_MODE = 0    		; set to 1 to adjust PIVOT easier
ROTATION_PIVOT = 0, 0, 0  	; rotation pivot relative to wing root node, should be at the center of wing mesh
ROTATION_AXIS = -1, 0, 0        ; I’m pretty sure in most cases, this value wouldn’t be changed, but just in case
DEBUG=0

[BASIC]
BACK_TO_THE_FUTURE=0
BRAKES_THRESHOLD=0.01
ENGINE_STALLED_RPM_THRESHOLD=1
HAS_CORRECT_COCKPIT_NODE=1
HAZARD_LIGHTS_ENGINE_LIFE_THRESHOLD=0.001
HEADLIGHTS_ARE_HEADLIGHTS=0
HORN_AS_SIREN=0
IS_LOW_BEAM_AVAILABLE=0
LIGHT_DAMAGE_SPEED_MAX=120
LIGHT_DAMAGE_SPEED_MIN=80
SHARE_POSITION_DATA_FOR_NAVIGATORS=1
STOP_LODS_ADJUSTMENT=0
TURNING_LIGHTS_REPEAT=1

[BOUNCED_BRAKE_LIGHTS]
ACTIVE=1
FADE_AT=200
FADE_SMOOTH=50
FALLOFF=0.7
GRADIENT_OFFSET=0.8
MULT=1, 1, 1, 1
OFFSET=7

[BOUNCED_HEADLIGHTS]
ACTIVE=1
FADE_AT=200
FADE_SMOOTH=50
FALLOFF=0.7
GRADIENT_OFFSET=0.8
MULT=1, 1, 1, 1
OFFSET=7

[BOUNCED_INTERIOR_LIGHT]
ACTIVE=1
DIRECTION=0, 1, -2
MULT=1, 1, 1, 1
OFFSET=0, -1, 3
RANGE=3.2
RANGE_GRADIENT_OFFSET=0.9
SPOT=20
SPOT_SHARPNESS=0.9

[BRAKEDISC_FX_FRONT]
ACTIVE = 1             		; set to 0 to disable the whole thing if car uses ksBrakeDisc shader for something else
CERAMIC = 0            		; use ceramic look
CARVED = 0             		; add a bit of carving, radial lines (fast for shader to compute)
CARVED_FREQUENCY = 20  		; increase to make more lines
GLOW_OFFSET = 0.9
DISC_RADIUS = 0.15         	; radius of a brake disc
DISC_INTERNAL_RADIUS = 0.1  	; radius of an inside part of a brake disc
RIM_RADIUS = 0.20  		; inside radius of a rim
RIM_HEIGHT = 0.04   		; distance between surface of brake disc and vertical surface of a wheel rim
LUMINOCITY_MASK = 0.252, 0.252
WEAR_FORCE = 1
REFLECTION_SHARPNESS = 5, 5
ALPHA_MASK=0.1, 0.2
CUTS=0
CUTS_ASPECT_RATIO=0.7
CUTS_FREQUENCY=2
CUTS_POINT_0=0.9, 0.15
CUTS_POINT_1=0.1, 0.85
CUTS_THICKNESS=0.04
CUTS_Y_EXP=1
GLOW_MULT=1
NORMAL_MASK=2, 1
OVERRIDE_DIFFUSE_MAP=1
OVERRIDE_NORMAL_MAP=1
REFLECTION_F0=0.08, 0.44
ROUGHNESS=0.2, 0.9
SPECULAR=0.5, 1
DEBUG = 0

[BRAKEDISC_FX_REAR]
ACTIVE = 1             		; set to 0 to disable the whole thing if car uses ksBrakeDisc shader for something else
CERAMIC = 0            		; use ceramic look
CARVED = 0             		; add a bit of carving, radial lines (fast for shader to compute)
CARVED_FREQUENCY = 20  		; increase to make more lines
GLOW_OFFSET = 0.9
DISC_RADIUS = 0.135           	; radius of a brake disc
DISC_INTERNAL_RADIUS = 0.09  	; radius of an inside part of a brake disc
RIM_RADIUS = 0.20  		; inside radius of a rim
RIM_HEIGHT = 0.04   		; distance between surface of brake disc and vertical surface of a wheel rim
LUMINOCITY_MASK = 0.252, 0.252
WEAR_FORCE = 1
REFLECTION_SHARPNESS = 5, 5
ALPHA_MASK=0.1, 0.2
CUTS=0
CUTS_ASPECT_RATIO=0.7
CUTS_FREQUENCY=2
CUTS_POINT_0=0.9, 0.15
CUTS_POINT_1=0.1, 0.85
CUTS_THICKNESS=0.04
CUTS_Y_EXP=1
GLOW_MULT=1
NORMAL_MASK=2, 1
OVERRIDE_DIFFUSE_MAP=1
OVERRIDE_NORMAL_MAP=1
REFLECTION_F0=0.08, 0.44
ROUGHNESS=0.2, 0.9
SPECULAR=0.5, 1
DEBUG = 0

[DATA]
DISABLE_ANALOGINSTRUMENTSINI=0
DISABLE_DIGITALPANELSINI=0
DISABLE_LIGHTSINI=0
HIGH_BEAMS_TINT=1, 1, 1
LIGHT_HEATING_CLAMP_rear_light_mesh_SUB_18=0.8
LIGHT_HEATING_CLAMP_rear_light_mesh_SUB_20=0.8
LIGHT_HEATING_EXP_rear_light_mesh_SUB_18=1
LIGHT_HEATING_EXP_rear_light_mesh_SUB_20=1
LIGHT_HEATING_K_rear_light_mesh_SUB_18=0
LIGHT_HEATING_K_rear_light_mesh_SUB_20=0
LIGHT_HEATING_MAP_rear_light_mesh_SUB_18=1, 0.7, 0
LIGHT_HEATING_MAP_rear_light_mesh_SUB_20=1, 0.7, 0
LIGHT_SWITCH_LAG_rear_light_mesh_SUB_18=0
LIGHT_SWITCH_LAG_rear_light_mesh_SUB_20=0
LOW_BEAMS_TINT=1, 1, 1

[EMISSIVE_EXTRA_A_...]
NAME = Headlight_Low	    ; name (one or more) of a mesh to glow
COLOR = 0,2000,600          ; glowing color if condition is met
OFF_COLOR = 0, 0, 0         ; glowing color otherwise, default value is 0
LAG = 0.4                   ; with zero, turns on and off immediately
SIMULATE_HEATING = 0        ; adds heating effect, going through orange tint while turning on and off
LOCATION = FRONT            ; light location used for damage and light guessing, default value depends on type
ACT_AS_HEADLIGHTS = 1       ; if set to 1, emissiveness is raised when camera is caught in car’s headlights
BLINK_REPEAT=0
CAST_LIGHT=1
INPUT_STALLED_IGNORE=1
LAG_DOWN=0.4
LAG_UP=0.4
TOGGLE_VISIBILITY = 1

[EXHAUST_FLAMES]
ANTILAG_DELAY=0.2
ANTILAG_INTENSITY=1
ANTILAG_INTERVAL_MAX=0.1
ANTILAG_INTERVAL_MIN=0.05
ANTILAG_TURBO_THRESHOLD=0.1
DAMAGE=1
DAMAGE_DURATION=0.05
DAMAGE_INTENSITY=1
DAMAGE_PROBABILITY=1
DISCHARGE=1
DISCHARGE_CHARGE_TIME=2
DISCHARGE_DELAY=1
DISCHARGE_DURATION=1
DISCHARGE_INTENSITY=0.115
DISCHARGE_PROBABILITY=0.705
DISCHARGE_RPM_THRESHOLD_MAX=8000
DISCHARGE_RPM_THRESHOLD_MIN=5000
DISCHARGE_WATER_TEMPERATURE_THRESHOLD=80
FLAT_SHIFT_COOLDOWN=0.23
FLAT_SHIFT_DURATION=0.05
FLAT_SHIFT_GAS_THRESHOLD=0.3
FLAT_SHIFT_INTENSITY=0.1
FLAT_SHIFT_PROBABILITY=1
FLAT_SHIFT_RPM_THRESHOLD=6000
LIMITER=1
LIMITER_DELAY=0.1
LIMITER_INTENSITY=0.01
LIMITER_RPM_THRESHOLD=7300

[EXTRA_FX]
MASK_GBUFFER = material:Ruecklicht_glas_rot
; SKIP_GBUFFER = material:Ruecklicht_glas_rot

[EXTRA_GUESSING]
FIX_WINDSCREENS=1

[FAKE_SHADOWS_FX]
CUSTOM_SKIN_SHADOWS=0
DISALLOW_REBAKING=0

[LIGHTING]
EMISSIVE_BRAKELIGHTS_MULT=1
EMISSIVE_HEADLIGHTS_MULT=1
EMISSIVE_MULT=1
EMISSIVE_PARKINGLIGHTS_MULT=1
FULLY_SHADOWED_INTERIOR=0
INTERIOR_FAKE_SHADOW_FADE=0.2
INTERIOR_FAKE_SHADOW_HEIGHT=0.1
INTERIOR_FAKE_SHADOW_OPACITY=0.9
INTERIOR_FAKE_UPPER_SHADOW_FADE=0.1
INTERIOR_FAKE_UPPER_SHADOW_HEIGHT=-0.1
LIT_MULT=1
SPECULAR_MULT=1

[LIGHT_BRAKE_0] 				; For Track not Car
AFFECTS_TRACK=1
COLOR=1, 0, 0, 20
DIFFUSE_CONCENTRATION=0.88
DIRECTION=0, 0, -1
EXTERIOR_ONLY=0
FADE_AT=120
FADE_SMOOTH=30
INTERIOR_ONLY=0
MIRROR=0.468203
OFF_COLOR=1, 0.0911936, 0.0265662, 1.05
OFF_FADE_MULT=1.674586
OFF_MIRROR=0.549986
OFF_MULT=0.1
OFF_POSITION=0, 0.54357, -2.56
OFF_RANGE_MULT=0.767561
POSITION=0, 0.547034, -2.43
RANGE=3
RANGE_GRADIENT_OFFSET=0.3
SPECULAR_MULT=1
SPOT=135.5
SPOT_EDGE=0.582, 0.582, 0.582
SPOT_EDGE_SHARPNESS=10
SPOT_SHARPNESS=0.3475
BOUND_EMISSIVE_MAX=500
BOUND_EXP=1
FADE_FAKE_SHADOW=0
LONG_SPECULAR=1
MIRROR_DIRECTION=0
NO_SELF_SPECULAR=1
PREFER_FRONT=-1
SINGLE_FREQUENCY=0

[LIGHT_HEADLIGHT_0]
BOUND_TO=Headlight_Low
AFFECTS_TRACK=1
BOUND_EMISSIVE_MAX=450
BOUND_EXP=1
COLOR=0.0, 1, 0.9, 20
DIFFUSE_CONCENTRATION=0.88
DIRECTION=0, 0, 1
EXTERIOR_ONLY=0
FADE_AT=350
FADE_FAKE_SHADOW=0
FADE_SMOOTH=50
INTERIOR_ONLY=0
LONG_SPECULAR=1
LOWBEAM_RANGE_MAX=70
LOWBEAM_RANGE_MULT=0.8
LOWBEAM_RANGE_ONCOMING_MULT=0.4
MIRROR=0.60
MIRROR_DIRECTION=0
NO_SELF_SPECULAR=1
OFF_COLOR=0.905263, 0.905263, 1, 6.45945
OFF_FADE_MULT=0.732692
OFF_MIRROR=0.665391
OFF_MULT=0
OFF_POSITION=0, 0.69348, 2.00578
OFF_RANGE_MULT=0.202266
POSITION=0, 0.6429418, 1.80578
PREFER_FRONT=-1
RANGE=240
RANGE_GRADIENT_OFFSET=0
SECOND_SPOT=150.6
SECOND_SPOT_INTENSITY=0.10
SECOND_SPOT_RANGE=80
SECOND_SPOT_SHARPNESS=0.4
SECOND_SPOT_SKIP=0.3
SINGLE_FREQUENCY=0
SPECULAR_MULT=1
SPOT=150
SPOT_EDGE=0.02088, 0.01992, 0.018
SPOT_EDGE_SHARPNESS=10
SPOT_SHARPNESS=0
SPOT_UP=0.0995037, 0.995037, 0
VOLUMETRIC_LIGHT=1

[LIGHT_BRAKEDISCS_FRONT]
ACTIVE=1
COLOR=1, 0.5, 0, 0

[LIGHT_BRAKEDISCS_REAR]
ACTIVE=1
COLOR=1, 0.5, 0, 0

[LIGHT_FLAME_0]
BRIGHTNESS_MULT=0.2
CAR_BRIGHTNESS_MULT=1
CAR_RANGE_MULT=0.2
COLOR=-1, -1, -1, -1
DEBUG=0
DIRECTION_MULT=1, 1, 1
FADE_AT=150
FADE_SMOOTH=30
OFFSET=0.2
RANGE=7
RANGE_GRADIENT_OFFSET=0.2
SPOT=221.168
SPOT_SHARPNESS=0.8

[NECK]
BOUNDS_HORIZONAL=-150, 150
BOUNDS_VERTICAL=-50, 50
GLANCE_ANGLE=20
GLANCE_ANGLE_BACK=25
LOOK_BACK_OFFSET=0.24, 0.07, 0.15
PAN_LIMIT=0.08, 0.06

[PARTICLES_FX]
BODY_SPARKS_AMOUNT=1
BODY_SPARKS_COLOR=1, 0.5, 0, 10
BODY_SPARKS_INTENSITY=1
BODY_SPARKS_LIFETIME=1
BRAKES_SMOKE=1
COLLIDER_0_SPARKS_AMOUNT=1
COLLIDER_0_SPARKS_COLOR=1, 0.5, 0, 10
COLLIDER_0_SPARKS_INTENSITY=0
COLLIDER_0_SPARKS_LIFETIME=1
COLLIDER_1_SPARKS_AMOUNT=3
COLLIDER_1_SPARKS_COLOR=1, 0.5, 0, 10
COLLIDER_1_SPARKS_INTENSITY=5
COLLIDER_1_SPARKS_LIFETIME=5
COLLIDER_2_SPARKS_AMOUNT=1
COLLIDER_2_SPARKS_COLOR=1, 0.5, 0, 10
COLLIDER_2_SPARKS_INTENSITY=1
COLLIDER_2_SPARKS_LIFETIME=1
COLLIDER_3_SPARKS_AMOUNT=1
COLLIDER_3_SPARKS_COLOR=1, 0.5, 0, 10
COLLIDER_3_SPARKS_INTENSITY=1
COLLIDER_3_SPARKS_LIFETIME=1
COLLIDER_4_SPARKS_AMOUNT=1
COLLIDER_4_SPARKS_COLOR=1, 0.5, 0, 10
COLLIDER_4_SPARKS_INTENSITY=1
COLLIDER_4_SPARKS_LIFETIME=1
DRAG_MULT=1
ENGINE_SMOKE=1
EXHAUST_SMOKE=1
LIFT_MULT=1
SMOKE_BS_OFFSET_FRONT=0, 0, 0
SMOKE_BS_OFFSET_MIDDLE=0, 0, 0
SMOKE_BS_OFFSET_REAR=0, 0, 0
SMOKE_BS_RADIUS_FRONT=1.05
SMOKE_BS_RADIUS_MIDDLE=1.05
SMOKE_BS_RADIUS_REAR=1.05
SMOKE_COLLIDER_OFFSET=0, 0
SMOKE_COLLIDER_RADIUS=2
SMOKE_FLAMES_POWER_APPEARING=60
SMOKE_FLAMES_POWER_MAIN=30
SMOKE_FLAMES_RADIUS_APPEARING=0.5
SMOKE_FLAMES_RADIUS_MAIN=1
SMOKE_PUSHAWAY_STRENGTH=12
SPARKS_AMOUNT_MULT=1
SPARKS_COOLDOWN_LAG=0.98
SPARKS_DEPTH_EXP=4
SPARKS_MAX_DEPTH=0.01
SPARKS_OVERLOAD_LAG=0.5
TRACES_LIGHTS_POS=0.549986, 0.54357, -2.43
TRACES_LIGHTS_SIZE=-1

[PARTICLES_FX_EXHAUST]
COLOR=0.7, 0.75, 0.9, 0.5
GAS_LAG=0.9
GROW=1, 1
INTENSITY=0.2, 0.4
INTENSITY_MULT=1
LIFE=1.6, 2
POSITION_OFFSET=0, 0, 0
SPAWN_OFFSET=0.02, 0.02
SPEED=0.4, 0.8
SPEED_THRESHOLD=5, 20
SPREAD=1, 1
STARTING_SIZE=0.03, 0.03
TEMPERATURE_LAG=0.9998
TEMPERATURE_THRESHOLD=9998, 9999

[PARTICLES_FX_EXHAUST_FLAMES]
COLOR_MULT=1, 1, 1, 1
INTENSITY_MULT=1
SIZE_MULT=1
TEMPERATURE_MULT=1

[REFLECTIONS_FX]
ALLOW_INTERIOR_SSAO=1
ALLOW_INTERIOR_SSGI=1
DISCARD_INTERIOR_MIRROR=1
MASK_CUBEMAP_ENABLED=1
MASK_CUBEMAP_OFFSET=0, -0.1, 0.2
MASK_CUBEMAP_TWEAK=0

[INCLUDE: common/custom_emissive.ini]

[CustomEmissive]
Meshes = DRIVER:HELMET_SUB0
Resolution =  1024, 256
@ = CustomEmissive_Rect, Channel =0, Mirror, Start = "652, 0", Size = "7, 256"
@ = DashIndicator, Input=EXTRA_B, Channel = 0, OffColor = "0,4,3", Intensity = 15, Color = "0,4,3", Intensity = 15

[SCRIPTABLE_DISPLAY_...]
MESHES = Display 	; mesh the SCRIPTABLE_DISPLAY draws onto.
SCRIPT = '

SmoothedAccel = {x = 0, z = 0} -- global default value definition for x and z axis of vec() car.acceleration.
function modeA(dt) -- first screem of the ADU, part of the switching function at the very bottom
	-- background for first screen
	display.image {
		image = "ADU1.dds",
        pos = vec2(0, -1), -- coordinates of top left corner
        size = vec2(2048, 2048)
    }

    -- rainbow rpm gauge
    local value = math.saturate(car.rpm / 8000) -- saturate clamps value between 0 and 1
    display.image {
        image = "RPM.dds", -- name of the texture to display
        pos = vec2(1, 397), -- coordinates of top left corner of the texture, pay attention to resolution of that texture
        size = vec2(2048 * value, 209), -- size of the image, "value *" makes it expand towards that maximum value
        uvStart = vec2(0, 0), -- uv coordinate of the top left corner (default is 0, 0)
        uvEnd = vec2(value, 1) -- uv coordinate of the bottom right corner (default is 1, 1), 0-8000rpms = value, 1 as range for the "uncovering fo the texture"
    }
    -- battery gauge
    local value = math.saturate(car.batteryVoltage / 15) -- saturate clamps value between 0 and 1
    display.image {
        image = "BATTERY.dds",
        pos = vec2(63, 789),
        size = vec2(515 * value, 66),
        uvStart = vec2(0, 0),
        uvEnd = vec2(value, 1)
    }
    -- fuel gauge
    local value = math.saturate(car.fuel / 20) -- saturate clamps value between 0 and 1
    display.image {
        image = "FUEL.dds",
        pos = vec2(63, 998),
        size = vec2(515 * value, 66),
        uvStart = vec2(0, 0),
        uvEnd = vec2(value, 1)
    }
    -- oil pressure gauge
    local value = math.saturate(car.oilPressure / 10) -- saturate clamps value between 0 and 1
    display.image {
        image = "OIL.dds",
        pos = vec2(63, 1206),
        size = vec2(515 * value, 66),
        uvStart = vec2(0, 0),
        uvEnd = vec2(value, 1)
    }
    -- gforce dot with smoothing
    SmoothedAccel.x = math.applyLag(SmoothedAccel.x, car.acceleration.x, 0.92, dt)
    SmoothedAccel.z = math.applyLag(SmoothedAccel.z, car.acceleration.z, 0.92, dt)
    local gDotPos = vec2(1577, 1056)
    local gDotMovementScaleX = 100
    local gDotMovementScaleZ = 100
    gDotPos.x = gDotPos.x + (math.max(math.min(SmoothedAccel.x, 2), -2) * gDotMovementScaleX)
    gDotPos.y = gDotPos.y + (math.max(math.min(SmoothedAccel.z, 2), -2) * gDotMovementScaleZ)
    display.image {
        image = "GF.dds",
        pos = vec2(gDotPos.x, gDotPos.y),
        size = vec2(50, 50)
    }
    -- gear display
    local gearText = tostring(car.gear) -- needs to be converted so that neutral and reverse display correctly (-1 = R, 0 = N)
    if car.gear == -1 then
        gearText = "R"
    end
    if car.gear == 0 then
        gearText = "N"
    end
    display.text {
        text = gearText,
        pos = vec2(600, 620),
        letter = vec2(600, 830),
        font = "c7_new",
        width = 46,
        alignment = 0.5,
        spacing = 0
    }
    -- numeric battery gauge
    display.text {
        text = string.format("%.1f", car.batteryVoltage), -- %.1f = 1 digit after comma, %.2f = 2 digits etc
        pos = vec2(430, 715),
        letter = vec2(40, 80),
        font = "c7_new",
        width = 46,
        alignment = 1,
        spacing = 0
    }
    -- numeric fuel gauge
    display.text {
        text = string.format("%.1f", car.fuel),
        pos = vec2(430, 925),
        letter = vec2(40, 80),
        font = "c7_new",
        width = 46,
        alignment = 1,
        spacing = 0
    }
    -- numeric oil pressure gauge
    display.text {
        text = string.format("%.1f", car.oilPressure),
        pos = vec2(470, 1130),
        letter = vec2(40, 80),
        font = "c7_new",
        width = 46,
        alignment = 1,
        spacing = 0
    }
    --numeric gforce gauges
    display.text {
        text = string.format("%.1f", (math.max(SmoothedAccel.x, 0))), -- SmoothedAccel.xyz replaces car.acceleration.xyz, math.max() calculates the biggest value from a list of numbers, "0" prevents the displayed value from going <0
        pos = vec2(1908, 1030),
        letter = vec2(50, 110),
        font = "c7_new",
        width = 46,
        alignment = 1,
        spacing = -10,
        color = rgbm(1, 0.5, 0, 1) -- rgbm is 0-1
    }
    display.text {
        text = string.format("%.1f", (math.max(SmoothedAccel.x * -1, 0))), -- *-1 to invert values for the opposite direction to prevent it from displaying negative values.
        pos = vec2(1165, 1030),
        letter = vec2(50, 110),
        font = "c7_new",
        width = 46,
        alignment = 1,
        spacing = -10,
        color = rgbm(1, 1, 1, 1)
    }
    display.text {
        text = string.format("%.1f", (math.max(SmoothedAccel.z * -1, 0))), -- z axis is actually forward/backward, y is up/down
        pos = vec2(1540, 685),
        letter = vec2(50, 110),
        font = "c7_new",
        width = 46,
        alignment = 1,
        spacing = -10,
        color = rgbm(1, 0.5, 0, 1)
    }
    display.text {
        text = string.format("%.1f", (math.max(SmoothedAccel.z, 0))),
        pos = vec2(1540, 1375),
        letter = vec2(50, 110),
        font = "c7_new",
        width = 46,
        alignment = 1,
        spacing = -10,
        color = rgbm(1, 1, 1, 1)
    }
    -- laptime gauge
    local time = car.lapTimeMs -- preparation for conversion from ms to minutes, seconds, milliseconds
    local formattedTime =
        string.format(
        "%02d:%02d:%02d",
        math.floor((time / (1000 * 60))) % 60,
        math.floor((time / 1000)) % 60,
        math.floor((time % 1000) / 100)
    )
    display.text {
        text = formattedTime,
        pos = vec2(40, 1535),
        letter = vec2(60, 120),
        font = "c7_new",
        width = 46,
        alignment = 1,
        spacing = -3
    }
    -- fastest lap gauge
    local time = car.bestLapTimeMs
    local formattedTime =
        string.format(
        "%02d:%02d:%02d",
        math.floor((time / (1000 * 60))) % 60,
        math.floor((time / 1000)) % 60,
        math.floor((time % 1000) / 100)
    )
    display.text {
        text = formattedTime,
        pos = vec2(1450, 1535),
        letter = vec2(60, 120),
        font = "c7_new",
        width = 46,
        alignment = 1,
        spacing = -3
    }
    -- clock
    display.text {
        text = string.format("%02d:%02d:%02d", sim.timeHours, sim.timeMinutes, sim.timeSeconds),
        pos = vec2(730, 1480),
        letter = vec2(70, 180),
        font = "c7_new",
        width = 46,
        alignment = 0.5,
        spacing = -3
    }
    -- speed gauge (with formatting for correct digit positions with additional digits appearing)
    digitCoords = {
        -- define your coords here
        vec2(670, 1230), -- the leftmost digit
        vec2(770, 1230), -- the center digit
        vec2(870, 1230) -- the rightmost digit
    }
    -- preparing our table of speed digits
    local displayspeed = tostring(math.floor(car.speedKmh)) -- math.floor rounds to the next full number
    local speedTable = {}
    for i = 1, string.len(displayspeed) do
        speedTable[i] = displayspeed:sub(i, i)
    end
    if string.len(displayspeed) == 1 then
        display.text {
            -- rightmost digit
            text = speedTable[1],
            pos = digitCoords[3],
            letter = vec2(100, 200),
            font = "c7_new",
            width = 16,
            spacing = 0,
            alignment = -1.0
        }
    elseif string.len(displayspeed) == 2 then
        display.text {
            -- rightmost digit
            text = speedTable[2],
            pos = digitCoords[3],
            letter = vec2(100, 200),
            font = "c7_new",
            width = 16,
            spacing = 0,
            alignment = -1.0
        }
        display.text {
            -- center digit
            text = speedTable[1],
            pos = digitCoords[2],
            letter = vec2(100, 200),
            font = "c7_new",
            width = 16,
            spacing = 0,
            alignment = -1.0
        }
    elseif string.len(displayspeed) == 3 then
        display.text {
            -- rightmost digit
            text = speedTable[3],
            pos = digitCoords[3],
            letter = vec2(100, 200),
            font = "c7_new",
            width = 16,
            spacing = 0,
            alignment = -1.0
        }
        display.text {
            -- center digit
            text = speedTable[2],
            pos = digitCoords[2],
            letter = vec2(100, 200),
            font = "c7_new",
            width = 16,
            spacing = 0,
            alignment = -1.0
        }
        display.text {
            -- leftmost digit
            text = speedTable[1],
            pos = digitCoords[1],
            letter = vec2(100, 200),
            font = "c7_new",
            width = 16,
            spacing = 0,
            alignment = -1.0
        }
    end
    -- oil pressure warning light
    if (car.oilPressure <= 1) then -- if oil pressure equals or drops below 1bar image gets displayed at defined position
        display.image {
            image = "OILW.dds",
            pos = vec2(1287, 1367), -- coordinates of top left corner
            size = vec2(175, 95)
        }
    end
    -- check engine light
    if (car.engineLifeLeft <= 600) then -- if engine life equals or drops below 600 life points image gets displayed, engine life is 0-1000
        display.image {
            image = "ENG.dds",
            pos = vec2(1853, 1348), -- coordinates of top left corner
            size = vec2(180, 125)
        }
    end
end
function modeB(dt) -- second screen
    -- grey background for second screen, draws on top of mesh texture so pay attention to transparency, might need layering depending on what youre doing
    display.image {
        image = "RPMB.dds",
        pos = vec2(0, 399),
        size = vec2(2048, 1248)
    }
    -- rpm gauge
    local rpmPercentage = (car.rpm / 8000 * 100) -- conversion to %
    for i = 1, 16 do
        local thisRotation = (-rpmPercentage) * 2.7 -- "-" turns rotation counter clockwise
        ui.beginRotation()
        ui.beginRotation()
        local color = rgbm(0, 255, 239, 255) -- normal colour of the displayed rectangle
        if car.rpm > 6000 then -- if rpms exceed 6000 colour switches
            color = rgbm(255, 0, 0, 255)
        end
        display.rect {
            -- draws rectangle
            pos = vec2(600, 1210),
            size = vec2(200, 200),
            color = color
        }
        ui.endRotation(30)
        if rpmPercentage > (100 / 16 * i) then
            thisRotation = -(100 / 16 * i) * 2.7
        end
        ui.endPivotRotation(thisRotation + 107, vec2(1001, 1021))
    end
    -- actual background for second screen, last in line since script runs top to bottom and transparency layer needs to be at the very top of the stack
    display.image {
        image = "ADU2.dds",
        pos = vec2(0, 399), -- coordinates of top left corner
        size = vec2(2048, 1248)
    }
    -- battery gauge
    local value = math.saturate(car.batteryVoltage / 15) -- saturate clamps value between 0 and 1
    display.image {
        image = "BOOST.dds",
        pos = vec2(47, 1514),
        size = vec2(518 * value, 59),
        uvStart = vec2(0, 0),
        uvEnd = vec2(value, 1)
    }
    -- boost gauge
    local value = math.saturate(car.turboBoost / 2) -- saturate clamps value between 0 and 1
    display.image {
        image = "BOOST.dds",
        pos = vec2(1430, 1514),
        size = vec2(518 * value, 59),
        uvStart = vec2(0, 0),
        uvEnd = vec2(value, 1)
    }
    -- water temperature gauge
    local value = math.saturate(car.waterTemperature / 120) -- saturate clamps value between 0 and 1
    display.image {
        image = "WATERT.dds",
        pos = vec2(48, 1299),
        size = vec2(108, -value * 755), -- -value to invert direction of expansion
        uvStart = vec2(0, 0), -- up/down instead of left/right
        uvEnd = vec2(1, value) -- up/down instead of left/right
    }
    -- oil temperature gauge
    local value = math.saturate(car.oilTemperature / 120) -- saturate clamps value between 0 and 1
    display.image {
        image = "OILT.dds",
        pos = vec2(1825, 1300),
        size = vec2(112, -value * 769),
        uvStart = vec2(0, 0),
        uvEnd = vec2(1, value)
    }
    -- numeric battery gauge
    display.text {
        text = string.format("%.1f", car.batteryVoltage),
        pos = vec2(35, 1420),
        letter = vec2(45, 90),
        font = "c7_new",
        width = 46,
        alignment = 1,
        spacing = -10
    }
    -- unit display for gauge, doesnt need to be part of the texture, can be drawn directly onto the mesh
    display.text {
        text = "V",
        pos = vec2(175, 1420),
        letter = vec2(65, 90),
        font = "c7_new",
        width = 46,
        alignment = 1,
        spacing = 0
    }
    -- numeric boost gauge
    display.text {
        text = string.format("%.1f", car.turboBoost),
        pos = vec2(1835, 1420),
        letter = vec2(45, 90),
        font = "c7_new",
        width = 46,
        alignment = 1,
        spacing = -10
    }
    -- unit
    display.text {
        text = "BOOST",
        pos = vec2(1535, 1420),
        letter = vec2(65, 90),
        font = "c7_new",
        width = 46,
        alignment = 1,
        spacing = -10
    }
    -- numeric water temp gauge
    display.text {
        text = string.format("%.1f", car.waterTemperature),
        pos = vec2(35, 440),
        letter = vec2(45, 90),
        font = "c7_new",
        width = 46,
        alignment = 1,
        spacing = -10
    }
    -- numeric oil temp gauge
    display.text {
        text = string.format("%.1f", car.oilTemperature),
        pos = vec2(1810, 440),
        letter = vec2(45, 90),
        font = "c7_new",
        width = 46,
        alignment = 1,
        spacing = -10
    }
    -- unit
    display.text {
        text = "C",
        pos = vec2(185, 440),
        letter = vec2(65, 90),
        font = "c7_new",
        width = 46,
        alignment = 1,
        spacing = -10
    }
    -- unit
    display.text {
        text = "C",
        pos = vec2(1960, 440),
        letter = vec2(65, 90),
        font = "c7_new",
        width = 46,
        alignment = 1,
        spacing = -10
    }
    -- speed gauge
    digitCoords = {
        -- define your coords here
        vec2(805, 900), -- left triple
        vec2(865, 900), -- left dual
        vec2(925, 900), -- center
        vec2(985, 900), -- right dual
        vec2(1045, 900) -- right triple
    }
    -- preparing our table of speed digits
    local displayspeed = tostring(math.floor(car.speedKmh))
    local speedTable = {}
    for i = 1, string.len(displayspeed) do
        speedTable[i] = displayspeed:sub(i, i)
    end
    if string.len(displayspeed) == 1 then
        display.text {
            -- rightmost digit
            text = speedTable[1],
            pos = digitCoords[3],
            letter = vec2(145, 240),
            font = "c7_new",
            width = 16,
            spacing = 0,
            alignment = -1.0
        }
    elseif string.len(displayspeed) == 2 then
        display.text {
            -- rightmost digit
            text = speedTable[2],
            pos = digitCoords[4],
            letter = vec2(145, 240),
            font = "c7_new",
            width = 16,
            spacing = 0,
            alignment = -1.0
        }
        display.text {
            -- leftmost digit
            text = speedTable[1],
            pos = digitCoords[2],
            letter = vec2(145, 240),
            font = "c7_new",
            width = 16,
            spacing = 0,
            alignment = -1.0
        }
    elseif string.len(displayspeed) == 3 then
        display.text {
            -- rightmost digit
            text = speedTable[3],
            pos = digitCoords[5],
            letter = vec2(145, 240),
            font = "c7_new",
            width = 16,
            spacing = 0,
            alignment = -1.0
        }
        display.text {
            -- center digit
            text = speedTable[2],
            pos = digitCoords[3],
            letter = vec2(145, 240),
            font = "c7_new",
            width = 16,
            spacing = 0,
            alignment = -1.0
        }
        display.text {
            -- leftmost digit
            text = speedTable[1],
            pos = digitCoords[1],
            letter = vec2(145, 240),
            font = "c7_new",
            width = 16,
            spacing = 0,
            alignment = -1.0
        }
    end
    -- numeric rpm gauge, same principal applies as for speed, this is for expansion from center to both directions instead of digits appearing to the left/right
    digitCoords = {
        -- define your coords here
        vec2(735, 1300), --left quad
        vec2(795, 1300), --left triple
        vec2(855, 1300), --left dual
        vec2(915, 1300), --center
        vec2(975, 1300), --right dual
        vec2(1035, 1300),
         --right triple
        vec2(1095, 1300) --right quad
    }
    -- preparing our table of rpm digits
    local displayrpm = tostring(math.floor(car.rpm))
    local rpmTable = {}
    for i = 1, string.len(displayrpm) do
        rpmTable[i] = displayrpm:sub(i, i)
    end
    if string.len(displayrpm) == 1 then
        display.text {
            -- rightmost digit
            text = rpmTable[1],
            pos = digitCoords[4],
            letter = vec2(145, 240),
            font = "c7_new",
            width = 16,
            spacing = 0,
            alignment = 1.0
        }
    elseif string.len(displayrpm) == 2 then
        display.text {
            -- rightmost digit
            text = rpmTable[2],
            pos = digitCoords[5],
            letter = vec2(145, 240),
            font = "c7_new",
            width = 16,
            spacing = 0,
            alignment = 1.0
        }
        display.text {
            -- leftmost digit
            text = rpmTable[1],
            pos = digitCoords[3],
            letter = vec2(145, 240),
            font = "c7_new",
            width = 16,
            spacing = 0,
            alignment = 1.0
        }
    elseif string.len(displayrpm) == 3 then
        display.text {
            -- rightmost digit
            text = rpmTable[3],
            pos = digitCoords[6],
            letter = vec2(145, 240),
            font = "c7_new",
            width = 16,
            spacing = 0,
            alignment = 1.0
        }
        display.text {
            -- center digit
            text = rpmTable[2],
            pos = digitCoords[4],
            letter = vec2(145, 240),
            font = "c7_new",
            width = 16,
            spacing = 0,
            alignment = 1.0
        }
        display.text {
            -- leftmost digit
            text = rpmTable[1],
            pos = digitCoords[2],
            letter = vec2(145, 240),
            font = "c7_new",
            width = 16,
            spacing = 0,
            alignment = 1.0
        }
    elseif string.len(displayrpm) == 4 then
        display.text {
            -- rightmost digit
            text = rpmTable[4],
            pos = digitCoords[7],
            letter = vec2(145, 240),
            font = "c7_new",
            width = 16,
            spacing = 0,
            alignment = 1.0
        }
        display.text {
            -- center digit
            text = rpmTable[3],
            pos = digitCoords[5],
            letter = vec2(145, 240),
            font = "c7_new",
            width = 16,
            spacing = 0,
            alignment = 1.0
        }
        display.text {
            -- leftmost digit
            text = rpmTable[2],
            pos = digitCoords[3],
            letter = vec2(145, 240),
            font = "c7_new",
            width = 16,
            spacing = 0,
            alignment = 1.0
        }
        display.text {
            -- leftmost digit
            text = rpmTable[1],
            pos = digitCoords[1],
            letter = vec2(145, 240),
            font = "c7_new",
            width = 16,
            spacing = 0,
            alignment = 1.0
        }
    end
end
function modeC(dt) -- third screen
end
-- display switch
local listOfModes = {modeA, modeB, modeC} -- you can add infinite displays, their elements need to be inside function modeN(dt)
local currentMode = 1 -- can be used to define default screen
local lastExtraCState = false
function update(dt)
    if car.extraC ~= lastExtraCState then -- switching is bound to extraC key, this tracks the state of extraC
        currentMode = currentMode + 1 -- you start at mode 1 and each extraC press adds +1 to the mode count
        if currentMode > #listOfModes then -- as soon as your mode counter exceeds the number of modes inside listOfModes it defaults back to mode 1
            currentMode = 1 -- should be the same as local currentMode =
        end
    end
    lastExtraCState = car.extraC
    listOfModes[currentMode](dt)
end
'

[INCLUDE]
INCLUDE=common/no_popup_lights.ini, common/f1_tyre_damage.ini

[SHADER_REPLACEMENT_...]
MATERIALS = V_Band
RESOURCE_2 = txMaps
PROP_... = ksSpecular, 1
PROP_... = ksSpecularEXP, 180
PROP_... = fresnelMaxLevel, 0.6
PROP_... = fresnelEXP, 0.6
PROP_... = fresnelC, 0.6

[SHADER_REPLACEMENT_...]
MATERIALS = Hose Clamps
PROP_... = ksSpecular, 1
PROP_... = ksSpecularEXP, 210
PROP_... = fresnelMaxLevel, 0.6
PROP_... = fresnelEXP, 0.6
PROP_... = fresnelC, 0.6

[SHADER_REPLACEMENT_...]
MATERIALS = Wastegate_Silver
PROP_... = ksSpecular, 0.5
PROP_... = ksSpecularEXP, 100
PROP_... = fresnelMaxLevel, 0.45
PROP_... = fresnelEXP, 0.45
PROP_... = fresnelC, 0.45

[SHADER_REPLACEMENT_...]; nicht veraendern wegen Shader
MATERIALS = Shock_Surge_Left
PROP_... = ksAmbient, 0.3
PROP_... = ksDiffuse, 0.3
PROP_... = ksSpecular, 0.3
PROP_... = ksSpecularEXP, 50
PROP_... = fresnelMaxLevel, 0.4
PROP_... = fresnelEXP, 13
PROP_... = fresnelC, 0.4

[SHADER_REPLACEMENT_...]; nicht veraendern wegen Shader
MATERIALS = Shock_Surge_Right
PROP_... = ksAmbient, 0.3
PROP_... = ksDiffuse, 0.3
PROP_... = ksSpecular, 0.3
PROP_... = ksSpecularEXP, 50
PROP_... = fresnelMaxLevel, 0.4
PROP_... = fresnelEXP, 13
PROP_... = fresnelC, 0.4

[SHADER_REPLACEMENT_...]; nicht veraendern wegen Shader
MATERIALS = Shock_Spring_Mint
PROP_... = ksAmbient, 0.14
PROP_... = ksDiffuse, 0.14
PROP_... = ksSpecular, 0.45
PROP_... = ksSpecularEXP, 15
PROP_... = fresnelMaxLevel, 0.2
PROP_... = fresnelEXP, 10
PROP_... = fresnelC, 0.2

[SHADER_REPLACEMENT_...]
MATERIALS = Rim_Black
PROP_... = ksAmbient, 0.3
Prop_... = ksDiffuse, 0.3

[SHADER_REPLACEMENT_...]
MATERIALS = Rotiform_Text
PROP_... = ksAmbient, 0.3
Prop_... = ksDiffuse, 0.3

[SHADER_REPLACEMENT_...]
MATERIALS = Ruecklicht_glas_rot
IS_TRANSPARENT = 1

[INCLUDE: common/materials_glass.ini]

[Material_Glass]
Materials = Ruecklicht_glas_rot
ThicknessMult = 0.2
BrightnessAdjustment = 0.3
Desaturate = 0
UseNormalMapWithAlpha = 1
MaskPass = 1

[SHADER_REPLACEMENT_...]
MATERIALS = Ruecklicht_glas_rot
PROP_... = ksAmbient, 0.35
PROP_... = ksDiffuse, 0.35

[SHADER_REPLACEMENT_...]
MATERIALS = RT_HELMET_Glass
SHADER = ksPerPixelReflection
BLEND_MODE = OPAQUE
IS_TRANSPARENT = 0

[SHADOWED_WHEELS_FRONT]
AFFECT_SUSP_NODES=1
ANGLE_X=0
BOUND_TO_SUSPENSION=0
DISTANCE=3
EXTRA_AMBIENT_BRIGHTNESS=0.12
OFFSET=0.04
WIDTH=0.1

[SHADOWED_WHEELS_REAR]
AFFECT_SUSP_NODES=1
ANGLE_X=0
BOUND_TO_SUSPENSION=0
DISTANCE=3
EXTRA_AMBIENT_BRIGHTNESS=0.12
OFFSET=0.04
WIDTH=0.1

[STATUS_BATTERY]
BASE_VOLTAGE=12.4
MAX_VOLTAGE=13.6
RPM_LAG=0.98

[STATUS_EXHAUST]
TEMPERATURE_BOOST=400
TEMPERATURE_IDLE=400
TEMPERATURE_LAG_DOWN=0.995
TEMPERATURE_LAG_UP=0.995
TEMPERATURE_RPM=100

[STATUS_OIL]
PRESSURE_BASE = 1.5         		; base oil pressure for idling engine
PRESSURE_STEP = 0.47        		; oil pressure increase for each 1000 RPM
PRESSURE_LAG_UP = 0.93   		; oil pressure increase lag
PRESSURE_LAG_DOWN = 0.9  		; oil pressure decrease lag
TEMPERATURE_MULT = 1.1         		; relation of oil temperature to water temperature
TEMPERATURE_RPM_FACTOR = 0.05  		; extra increase of oil temperature for each 1000 RPM
TEMPERATURE_LAG_UP = 0    		; oil temperature increase lag
TEMPERATURE_LAG_DOWN = 0.9997   	; oil temperature decrease lag
TEMPERATURE_OFFSET=0

[TYRES_FX]
BROKEN_TYRES_DYNAMIC=1

[TYRES_FX_FRONT]
CUSTOM_NORMALS_SCALE=15
DAMAGE_FLAT_SPOT_DEBUG=0
DAMAGE_GRAIN_DEBUG=0
DAMAGE_NORMALS_MULT=0.9
DAMAGE_OCCLUSION_MULT=0.1
DAMAGE_REFL_MULT=0.8
DAMAGE_SPEC_EXP_MULT=0.8
DAMAGE_SPEC_MULT=0.9
DAMAGE_WIDTH_K=1.48
DAMAGE_OFFSET_K=0.05
DAMAGE_FLAT_SPOT_GAIN=30
DAMAGE_FLAT_SPOT_FADE=0.1
DAMAGE_GRAIN_GAIN=2
DAMAGE_GRAIN_MAX=0.9
DIRT_ACCUMULATION=1000
DIRT_DIRT_DEBUG=0
DIRT_GRASS_DEBUG=0
DIRT_FADE=50
DIRT_WIDTH_K=1.3
DIRT_OFFSET_K=-0.01
ENABLED=1
FLEX_MAX_SKEW_MULT=0.8
FLEX_MULT=3
FLEX_PROFILE_MULT=0.45
FLEX_SKEW_RANGE_MULT=3
FLEX_SKEW_SMOOTHING=0.1
FLEX_SQUASH_SMOOTHING=0.1
NOFX_DISTANCE_SWITCH=48
VISIBLE_IN_INTERIOR_CAM=1

[TYRES_FX_REAR]
CUSTOM_NORMALS_SCALE=15
DAMAGE_FLAT_SPOT_DEBUG=0
DAMAGE_GRAIN_DEBUG=0
DAMAGE_NORMALS_MULT=0.9
DAMAGE_OCCLUSION_MULT=0.1
DAMAGE_REFL_MULT=0.8
DAMAGE_SPEC_EXP_MULT=0.8
DAMAGE_SPEC_MULT=0.9
DAMAGE_WIDTH_K=1.59
DAMAGE_OFFSET_K=0.05
DAMAGE_FLAT_SPOT_GAIN=30
DAMAGE_FLAT_SPOT_FADE=0.1
DAMAGE_GRAIN_GAIN=2
DAMAGE_GRAIN_MAX=0.9
DIRT_ACCUMULATION=1000
DIRT_DIRT_DEBUG=0
DIRT_GRASS_DEBUG=0
DIRT_FADE=50
DIRT_WIDTH_K=1.34
DIRT_OFFSET_K=-0.03
ENABLED=1
FLEX_MAX_SKEW_MULT=0.8
FLEX_MULT=3
FLEX_PROFILE_MULT=0.45
FLEX_SKEW_RANGE_MULT=3
FLEX_SKEW_SMOOTHING=0.1
FLEX_SQUASH_SMOOTHING=0.1
NOFX_DISTANCE_SWITCH=48
VISIBLE_IN_INTERIOR_CAM=1

[WHEEL_LF]
IS_OPEN=1

[WHEEL_LR]
IS_OPEN=1

[WHEEL_RF]
IS_OPEN=1

[WHEEL_RR]
IS_OPEN=1

[WOBBLY_BIT_0]
NAME = Gearbox_Wobble	  		; name of the node to move
CONNECTED_TO = 0, 0, 0   		; point to which node is attached to, and around which it will rotate
MAX_RANGE = 0.03                 	; max range node can move from its original position
DAMPENING_LAG = 0.8          	; think of it as usual AC lag value, trying to zero node’s speed
G_GAIN = 5                    	; how much G-forces affect node’s speed
GRAVITY_GAIN = 1               	; how much gravity affects node’s speed
OFFSET_GAIN = 1200              	; how strong is returning force
STIFF_AXIS = 0, 0, 1            	; optional higher stiffness axis to reduce movement along it
STIFF_AXIS_STIFFNESS = 0.8      	; now stiff is optional stiffness axis
G_FILTER = 0                    	; temporal filter for G-forces
DEFAULT_GRAVITY_INCLUDED_ALREADY = 1 	; either `0` or `1`; set it to `1` if you don’t want gravity to skew your stuff when car is in neutral position
FORCE_OFFSET=0, 0, 0

[WOBBLY_BIT_1]
NAME = Rear_Light_Wobble	  	; name of the node to move
CONNECTED_TO = 0, 0, 0   		; point to which node is attached to, and around which it will rotate
MAX_RANGE = 0.01             	; max range node can move from its original position
DAMPENING_LAG = 0.8            		; think of it as usual AC lag value, trying to zero node’s speed
G_GAIN = 3                    	; how much G-forces affect node’s speed
GRAVITY_GAIN = 1                	; how much gravity affects node’s speed
OFFSET_GAIN = 2000              	; how strong is returning force
STIFF_AXIS = 0, 0, 1            	; optional higher stiffness axis to reduce movement along it
STIFF_AXIS_STIFFNESS = 1	      	; now stiff is optional stiffness axis
G_FILTER = 0                    	; temporal filter for G-forces
DEFAULT_GRAVITY_INCLUDED_ALREADY = 1 	; either `0` or `1`; set it to `1` if you don’t want gravity to skew your stuff when car is in neutral position
FORCE_OFFSET=0, 0, 0

[WOBBLY_BIT_2]
NAME = Diffuser_Wobble	  		; name of the node to move
CONNECTED_TO = 0, 0, 0   		; point to which node is attached to, and around which it will rotate
MAX_RANGE = 0.01                 	; max range node can move from its original position
DAMPENING_LAG = 0.90            	; think of it as usual AC lag value, trying to zero node’s speed
G_GAIN = 2                     		; how much G-forces affect node’s speed
GRAVITY_GAIN = 1                	; how much gravity affects node’s speed
OFFSET_GAIN = 4000              	; how strong is returning force
STIFF_AXIS = 0, 0, 1            	; optional higher stiffness axis to reduce movement along it
STIFF_AXIS_STIFFNESS = 1      		; now stiff is optional stiffness axis
G_FILTER = 0                    	; temporal filter for G-forces
DEFAULT_GRAVITY_INCLUDED_ALREADY = 1 	; either `0` or `1`; set it to `1` if you don’t want gravity to skew your stuff when car is in neutral position
FORCE_OFFSET=0, 0, 0

[WOBBLY_BIT_3]
NAME = Tank_Wobble	  		; name of the node to move
CONNECTED_TO = 0, 0, 0   		; point to which node is attached to, and around which it will rotate
MAX_RANGE = 0.02                 	; max range node can move from its original position
DAMPENING_LAG = 0.93            	; think of it as usual AC lag value, trying to zero node’s speed
G_GAIN = 3                      	; how much G-forces affect node’s speed
GRAVITY_GAIN = 1                	; how much gravity affects node’s speed
OFFSET_GAIN = 3000              	; how strong is returning force
STIFF_AXIS = 0, 0, 0            	; optional higher stiffness axis to reduce movement along it
STIFF_AXIS_STIFFNESS = 0.8      	; now stiff is optional stiffness axis
G_FILTER = 0                    	; temporal filter for G-forces
DEFAULT_GRAVITY_INCLUDED_ALREADY = 1 	; either `0` or `1`; set it to `1` if you don’t want gravity to skew your stuff when car is in neutral position
FORCE_OFFSET=0, 0, 0

[WOBBLY_BIT_4]
NAME = Intake_Wobble	  		; name of the node to move
CONNECTED_TO = 0, 0, 0   		; point to which node is attached to, and around which it will rotate
MAX_RANGE = 0.02                	; max range node can move from its original position
DAMPENING_LAG = 0.93            	; think of it as usual AC lag value, trying to zero node’s speed
G_GAIN = 2                      	; how much G-forces affect node’s speed
GRAVITY_GAIN = 1                	; how much gravity affects node’s speed
OFFSET_GAIN = 3000              	; how strong is returning force
STIFF_AXIS = 0, 0, 0            	; optional higher stiffness axis to reduce movement along it
STIFF_AXIS_STIFFNESS = 0.8      	; now stiff is optional stiffness axis
G_FILTER = 0                    	; temporal filter for G-forces
DEFAULT_GRAVITY_INCLUDED_ALREADY = 1 	; either `0` or `1`; set it to `1` if you don’t want gravity to skew your stuff when car is in neutral position
FORCE_OFFSET=0, 0, 0

